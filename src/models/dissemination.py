"""
Dissemination Models
====================

Data structures for information dissemination decisions and outgoing messages.
"""

from datetime import datetime
from typing import List, Dict, Optional, Literal, Any
from pydantic import BaseModel, Field


class DisseminationDecision(BaseModel):
    """
    Decision about who receives what information
    
    Generated by the dissemination router agent based on need-to-know policy
    and access control rules.
    """
    decision_id: str = Field(..., description="Unique identifier for this decision")
    timestamp: datetime = Field(..., description="When this decision was made")
    
    # Recipient information
    recipient_id: str = Field(..., description="ID of the downstream system")
    recipient_type: str = Field(..., description="Type: allied_bms, tactical_radio, etc.")
    
    # Access control
    recipient_access_level: Literal[
        "top_secret_access",
        "secret_access",
        "confidential_access",
        "restricted_access",
        "unclassified_access",
        "enemy_access"
    ] = Field(
        ...,
        description="Recipient's access level (determines what classifications they can see)"
    )
    
    # What information to share
    information_subset: List[str] = Field(
        ...,
        description="List of entity IDs to share with this recipient"
    )
    
    # Classification and security
    highest_classification_sent: Literal["TOP_SECRET", "SECRET", "CONFIDENTIAL", "RESTRICTED", "UNCLASSIFIED"] = Field(
        ...,
        description="Highest classification level in this transmission"
    )
    
    # Reasoning (for audit trail)
    reasoning: str = Field(
        ...,
        description="Why this recipient needs this information"
    )
    
    # Format requirements
    format_required: str = Field(
        ...,
        description="Output format required by recipient (link16, json, voice, etc.)"
    )
    
    # Human review
    requires_human_approval: bool = Field(
        False,
        description="Whether this dissemination requires human approval"
    )
    
    approved: Optional[bool] = Field(None, description="Human approval status")
    approval_timestamp: Optional[datetime] = Field(None, description="When approved/rejected")
    
    # Deception operations
    is_deception: bool = Field(
        False,
        description="True if this transmission contains disinformation (honeypot for enemy_access)"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "decision_id": "diss_001",
                "timestamp": "2025-10-15T14:30:00Z",
                "recipient_id": "allied_bms_uk",
                "recipient_type": "bms",
                "recipient_access_level": "secret_access",
                "information_subset": ["aircraft_T001", "radar_base_01"],
                "highest_classification_sent": "SECRET",
                "reasoning": "UK forces have SECRET clearance, threat in adjacent airspace",
                "format_required": "link16",
                "requires_human_approval": True,
                "approved": None,
                "is_deception": False
            }
        }


class OutgoingMessage(BaseModel):
    """
    Formatted message ready for transmission to downstream system
    
    The 'content' field structure depends on 'format_type'.
    Format adapters (in nodes/) handle EntityCOP â†’ specific format transformation.
    """
    message_id: str = Field(..., description="Unique message identifier")
    decision_id: str = Field(..., description="Reference to DisseminationDecision")
    recipient_id: str = Field(..., description="Target system ID")
    
    # Format specification
    format_type: Literal["link16", "json", "asterix", "cot", "voice_text", "custom"] = Field(
        ...,
        description="Output format type"
    )
    
    # Flexible content - structure depends on format_type
    content: Dict[str, Any] = Field(
        ...,
        description="Formatted message content (structure varies by format_type)"
    )
    
    # Metadata
    timestamp: datetime = Field(..., description="When message was generated")
    transmitted: bool = Field(False, description="Whether message was sent")
    transmission_timestamp: Optional[datetime] = Field(None, description="When transmitted")
    transmission_status: Optional[str] = Field(None, description="Status: success, failed, pending")
    
    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "message_id": "msg_001",
                    "decision_id": "diss_001",
                    "recipient_id": "allied_bms_uk",
                    "format_type": "link16",
                    "content": {
                        "message_type": "J3.2",
                        "track_number": "T001",
                        "position": {"lat": 39.5, "lon": -0.4},
                        "classification": "unknown"
                    },
                    "timestamp": "2025-10-15T14:30:05Z",
                    "transmitted": False,
                    "transmission_timestamp": None,
                    "transmission_status": "pending"
                },
                {
                    "message_id": "msg_002",
                    "format_type": "json",
                    "content": {
                        "entities": [
                            {"id": "T001", "type": "aircraft", "location": {"lat": 39.5, "lon": -0.4}}
                        ]
                    }
                },
                {
                    "message_id": "msg_003",
                    "format_type": "voice_text",
                    "content": {
                        "text": "Attention all stations, unknown aircraft track T001 detected at grid 39.5 North, 0.4 West, altitude 5000 meters"
                    }
                }
            ]
        }


class RecipientConfig(BaseModel):
    """
    Configuration for a downstream recipient system
    
    Loaded from configs/recipients.yaml
    """
    recipient_id: str = Field(..., description="Unique identifier")
    recipient_type: str = Field(..., description="Type of system")
    
    # Access control
    access_level: Literal[
        "top_secret_access",
        "secret_access",
        "confidential_access",
        "restricted_access",
        "unclassified_access",
        "enemy_access"
    ] = Field(
        ...,
        description="Recipient's access level (determines what they can see)"
    )
    
    supported_formats: List[str] = Field(..., description="List of supported formats")
    connection_type: str = Field(..., description="How to connect: mqtt, api, radio, etc.")
    connection_config: Dict = Field(default_factory=dict, description="Connection parameters")
    auto_disseminate: bool = Field(False, description="Auto-send without review")
    
    # Deception configuration (for enemy_access)
    deception_config: Optional[Dict[str, Any]] = Field(
        None,
        description="Configuration for disinformation if access_level is enemy_access"
    )
    
    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "recipient_id": "allied_bms_uk",
                    "recipient_type": "bms",
                    "access_level": "secret_access",
                    "supported_formats": ["link16", "json"],
                    "connection_type": "mqtt",
                    "connection_config": {
                        "mqtt_topic": "tifda/output/allied_bms_uk",
                        "qos": 2
                    },
                    "auto_disseminate": False
                },
                {
                    "recipient_id": "adversary_monitor",
                    "recipient_type": "honeypot",
                    "access_level": "enemy_access",
                    "supported_formats": ["json"],
                    "connection_type": "mqtt",
                    "connection_config": {
                        "mqtt_topic": "tifda/output/adversary_monitor",
                        "qos": 0
                    },
                    "deception_config": {
                        "mix_real_and_fake": True,
                        "fake_entity_ratio": 0.3,
                        "delay_seconds": 300
                    }
                }
            ]
        }